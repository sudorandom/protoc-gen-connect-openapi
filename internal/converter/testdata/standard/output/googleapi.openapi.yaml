openapi: 3.1.0
info:
  title: io.swagger.petstore.v2
  description: '## io.swagger.petstore.v2.Foo'
paths:
  /.well-known/jwks.json:
    get:
      tags:
        - io.swagger.petstore.v2.Foo
      summary: Foo
      operationId: io.swagger.petstore.v2.Foo.Foo
      responses:
        "200":
          description: Success
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/google.protobuf.Empty'
  /io.swagger.petstore.v2.Foo/Masky:
    post:
      tags:
        - io.swagger.petstore.v2.Foo
      summary: Masky
      operationId: io.swagger.petstore.v2.Foo.Masky
      parameters:
        - name: Connect-Protocol-Version
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/connect-protocol-version'
        - name: Connect-Timeout-Ms
          in: header
          schema:
            $ref: '#/components/schemas/connect-timeout-header'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/io.swagger.petstore.v2.MaskyRequest'
        required: true
      responses:
        default:
          description: Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/connect.error'
        "200":
          description: Success
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/google.protobuf.Empty'
  /timestampy:
    get:
      tags:
        - io.swagger.petstore.v2.Foo
      summary: Timestampy
      operationId: io.swagger.petstore.v2.Foo.Timestampy
      parameters:
        - name: ts
          in: query
          schema:
            type: string
            examples:
              - "2023-01-15T01:30:15.01Z"
              - "2024-12-25T12:00:00Z"
            format: date-time
            description: |-
              A Timestamp represents a point in time independent of any time zone or local
               calendar, encoded as a count of seconds and fractions of seconds at
               nanosecond resolution. The count is relative to an epoch at UTC midnight on
               January 1, 1970, in the proleptic Gregorian calendar which extends the
               Gregorian calendar backwards to year one.

               All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
               second table is needed for interpretation, using a [24-hour linear
               smear](https://developers.google.com/time/smear).

               The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
               restricting to that range, we ensure that we can convert to and from [RFC
               3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.

               # Examples

               Example 1: Compute Timestamp from POSIX `time()`.

                   Timestamp timestamp;
                   timestamp.set_seconds(time(NULL));
                   timestamp.set_nanos(0);

               Example 2: Compute Timestamp from POSIX `gettimeofday()`.

                   struct timeval tv;
                   gettimeofday(&tv, NULL);

                   Timestamp timestamp;
                   timestamp.set_seconds(tv.tv_sec);
                   timestamp.set_nanos(tv.tv_usec * 1000);

               Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.

                   FILETIME ft;
                   GetSystemTimeAsFileTime(&ft);
                   UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;

                   // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
                   // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
                   Timestamp timestamp;
                   timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
                   timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));

               Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.

                   long millis = System.currentTimeMillis();

                   Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
                       .setNanos((int) ((millis % 1000) * 1000000)).build();

               Example 5: Compute Timestamp from Java `Instant.now()`.

                   Instant now = Instant.now();

                   Timestamp timestamp =
                       Timestamp.newBuilder().setSeconds(now.getEpochSecond())
                           .setNanos(now.getNano()).build();

               Example 6: Compute Timestamp from current time in Python.

                   timestamp = Timestamp()
                   timestamp.GetCurrentTime()

               # JSON Mapping

               In JSON format, the Timestamp type is encoded as a string in the
               [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
               format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
               where {year} is always expressed using four digits while {month}, {day},
               {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
               seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
               are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
               is required. A proto3 JSON serializer should always use UTC (as indicated by
               "Z") when printing the Timestamp type and a proto3 JSON parser should be
               able to accept both UTC and other timezones (as indicated by an offset).

               For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
               01:30 UTC on January 15, 2017.

               In JavaScript, one can convert a Date object to this format using the
               standard
               [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
               method. In Python, a standard `datetime.datetime` object can be converted
               to this format using
               [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
               the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
               the Joda Time's [`ISODateTimeFormat.dateTime()`](
               http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()
               ) to obtain a formatter capable of generating timestamps in this format.
        - name: s
          in: query
          schema:
            type: string
            description: |-
              Wrapper message for `string`.

               The JSON representation for `StringValue` is JSON string.

               Not recommended for use in new APIs, but still useful for legacy APIs and
               has no plan to be removed.
      responses:
        "200":
          description: Success
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/google.protobuf.Empty'
  /v1/messages/{message}:
    get:
      tags:
        - io.swagger.petstore.v2.Foo
      summary: NamedPathPatterns
      operationId: io.swagger.petstore.v2.Foo.NamedPathPatterns
      parameters:
        - name: message
          in: path
          description: The message id.
          required: true
          schema:
            type: string
        - name: propertyInPath
          in: query
          schema:
            type: string
            title: property_in_path
        - name: propertyInQuery
          in: query
          schema:
            type: string
            title: property_in_query
      responses:
        "200":
          description: Success
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/google.protobuf.Empty'
  /v1/organizations/{organization}/teams/{team}/all/members/{member}:
    get:
      tags:
        - io.swagger.petstore.v2.Foo
      summary: NamedPathPatternsWithLiteralSegment
      operationId: io.swagger.petstore.v2.Foo.NamedPathPatternsWithLiteralSegment
      parameters:
        - name: organization
          in: path
          description: The organization id.
          required: true
          schema:
            type: string
        - name: team
          in: path
          description: The team id.
          required: true
          schema:
            type: string
        - name: member
          in: path
          description: The member id.
          required: true
          schema:
            type: string
        - name: propertyInPath
          in: query
          schema:
            type: string
            title: property_in_path
        - name: propertyInQuery
          in: query
          schema:
            type: string
            title: property_in_query
      responses:
        "200":
          description: Success
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/google.protobuf.Empty'
  /v1/{property_in_path_ok}/{parentMsg.property_in_path}/foo:
    get:
      tags:
        - io.swagger.petstore.v2.Foo
      summary: Foo2
      operationId: io.swagger.petstore.v2.Foo.Foo2
      parameters:
        - name: property_in_path_ok
          in: path
          required: true
          schema:
            type: string
            title: property_in_path_ok
        - name: parentMsg.property_in_path
          in: path
          required: true
          schema:
            type: string
            title: property_in_path
        - name: parentMsg.propertyInQuery
          in: query
          schema:
            type: string
            title: property_in_query
        - name: propertyInQueryOk
          in: query
          schema:
            type: string
            title: property_in_query_ok
      responses:
        "200":
          description: Success
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/io.swagger.petstore.v2.Foo2Response'
components:
  schemas:
    connect-protocol-version:
      type: number
      title: Connect-Protocol-Version
      enum:
        - 1
      description: Define the version of the Connect protocol
      const: 1
    connect-timeout-header:
      type: number
      title: Connect-Timeout-Ms
      description: Define the timeout, in ms
    connect.error:
      type: object
      properties:
        code:
          type: string
          examples:
            - not_found
          enum:
            - canceled
            - unknown
            - invalid_argument
            - deadline_exceeded
            - not_found
            - already_exists
            - permission_denied
            - resource_exhausted
            - failed_precondition
            - aborted
            - out_of_range
            - unimplemented
            - internal
            - unavailable
            - data_loss
            - unauthenticated
          description: The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
        message:
          type: string
          description: A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.
        details:
          type: array
          items:
            $ref: '#/components/schemas/connect.error_details.Any'
          description: A list of messages that carry the error details. There is no limit on the number of messages.
      title: Connect Error
      additionalProperties: true
      description: 'Error type returned by Connect: https://connectrpc.com/docs/go/errors/#http-representation'
    connect.error_details.Any:
      type: object
      properties:
        type:
          type: string
          description: 'A URL that acts as a globally unique identifier for the type of the serialized message. For example: `type.googleapis.com/google.rpc.ErrorInfo`. This is used to determine the schema of the data in the `value` field and is the discriminator for the `debug` field.'
        value:
          type: string
          format: binary
          description: The Protobuf message, serialized as bytes and base64-encoded. The specific message type is identified by the `type` field.
        debug:
          oneOf:
            - type: object
              title: Any
              additionalProperties: true
              description: Detailed error information.
          discriminator:
            propertyName: type
          title: Debug
          description: Deserialized error detail payload. The 'type' field indicates the schema. This field is for easier debugging and should not be relied upon for application logic.
      additionalProperties: true
      description: Contains an arbitrary serialized message along with a @type that describes the type of the serialized message, with an additional debug field for ConnectRPC error details.
    google.protobuf.Empty:
      type: object
      description: |-
        A generic empty message that you can re-use to avoid defining duplicated
         empty messages in your APIs. A typical example is to use it as the request
         or the response type of an API method. For instance:

             service Foo {
               rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
             }
    google.protobuf.FieldMask:
      type: string
      description: |-
        `FieldMask` represents a set of symbolic field paths, for example:

             paths: "f.a"
             paths: "f.b.d"

         Here `f` represents a field in some root message, `a` and `b`
         fields in the message found in `f`, and `d` a field found in the
         message in `f.b`.

         Field masks are used to specify a subset of fields that should be
         returned by a get operation or modified by an update operation.
         Field masks also have a custom JSON encoding (see below).

         # Field Masks in Projections

         When used in the context of a projection, a response message or
         sub-message is filtered by the API to only contain those fields as
         specified in the mask. For example, if the mask in the previous
         example is applied to a response message as follows:

             f {
               a : 22
               b {
                 d : 1
                 x : 2
               }
               y : 13
             }
             z: 8

         The result will not contain specific values for fields x,y and z
         (their value will be set to the default, and omitted in proto text
         output):


             f {
               a : 22
               b {
                 d : 1
               }
             }

         A repeated field is not allowed except at the last position of a
         paths string.

         If a FieldMask object is not present in a get operation, the
         operation applies to all fields (as if a FieldMask of all fields
         had been specified).

         Note that a field mask does not necessarily apply to the
         top-level response message. In case of a REST get operation, the
         field mask applies directly to the response, but in case of a REST
         list operation, the mask instead applies to each individual message
         in the returned resource list. In case of a REST custom method,
         other definitions may be used. Where the mask applies will be
         clearly documented together with its declaration in the API.  In
         any case, the effect on the returned resource/resources is required
         behavior for APIs.

         # Field Masks in Update Operations

         A field mask in update operations specifies which fields of the
         targeted resource are going to be updated. The API is required
         to only change the values of the fields as specified in the mask
         and leave the others untouched. If a resource is passed in to
         describe the updated values, the API ignores the values of all
         fields not covered by the mask.

         If a repeated field is specified for an update operation, new values will
         be appended to the existing repeated field in the target resource. Note that
         a repeated field is only allowed in the last position of a `paths` string.

         If a sub-message is specified in the last position of the field mask for an
         update operation, then new value will be merged into the existing sub-message
         in the target resource.

         For example, given the target message:

             f {
               b {
                 d: 1
                 x: 2
               }
               c: [1]
             }

         And an update message:

             f {
               b {
                 d: 10
               }
               c: [2]
             }

         then if the field mask is:

          paths: ["f.b", "f.c"]

         then the result will be:

             f {
               b {
                 d: 10
                 x: 2
               }
               c: [1, 2]
             }

         An implementation may provide options to override this default behavior for
         repeated and message fields.

         In order to reset a field's value to the default, the field must
         be in the mask and set to the default value in the provided resource.
         Hence, in order to reset all fields of a resource, provide a default
         instance of the resource and set all fields in the mask, or do
         not provide a mask as described below.

         If a field mask is not present on update, the operation applies to
         all fields (as if a field mask of all fields has been specified).
         Note that in the presence of schema evolution, this may mean that
         fields the client does not know and has therefore not filled into
         the request will be reset to their default. If this is unwanted
         behavior, a specific service may require a client to always specify
         a field mask, producing an error if not.

         As with get operations, the location of the resource which
         describes the updated values in the request message depends on the
         operation kind. In any case, the effect of the field mask is
         required to be honored by the API.

         ## Considerations for HTTP REST

         The HTTP kind of an update operation which uses a field mask must
         be set to PATCH instead of PUT in order to satisfy HTTP semantics
         (PUT must only be used for full updates).

         # JSON Encoding of Field Masks

         In JSON, a field mask is encoded as a single string where paths are
         separated by a comma. Fields name in each path are converted
         to/from lower-camel naming conventions.

         As an example, consider the following message declarations:

             message Profile {
               User user = 1;
               Photo photo = 2;
             }
             message User {
               string display_name = 1;
               string address = 2;
             }

         In proto a field mask for `Profile` may look as such:

             mask {
               paths: "user.display_name"
               paths: "photo"
             }

         In JSON, the same mask is represented as below:

             {
               mask: "user.displayName,photo"
             }

         # Field Masks and Oneof Fields

         Field masks treat fields in oneofs just as regular fields. Consider the
         following message:

             message SampleMessage {
               oneof test_oneof {
                 string name = 4;
                 SubMessage sub_message = 9;
               }
             }

         The field mask can be:

             mask {
               paths: "name"
             }

         Or:

             mask {
               paths: "sub_message"
             }

         Note that oneof type names ("test_oneof" in this case) cannot be used in
         paths.

         ## Field Mask Verification

         The implementation of any API method which has a FieldMask type field in the
         request should verify the included field paths, and return an
         `INVALID_ARGUMENT` error if any path is unmappable.
    google.protobuf.StringValue:
      type: string
      description: |-
        Wrapper message for `string`.

         The JSON representation for `StringValue` is JSON string.

         Not recommended for use in new APIs, but still useful for legacy APIs and
         has no plan to be removed.
    google.protobuf.Timestamp:
      type: string
      examples:
        - "2023-01-15T01:30:15.01Z"
        - "2024-12-25T12:00:00Z"
      format: date-time
      description: |-
        A Timestamp represents a point in time independent of any time zone or local
         calendar, encoded as a count of seconds and fractions of seconds at
         nanosecond resolution. The count is relative to an epoch at UTC midnight on
         January 1, 1970, in the proleptic Gregorian calendar which extends the
         Gregorian calendar backwards to year one.

         All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
         second table is needed for interpretation, using a [24-hour linear
         smear](https://developers.google.com/time/smear).

         The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
         restricting to that range, we ensure that we can convert to and from [RFC
         3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.

         # Examples

         Example 1: Compute Timestamp from POSIX `time()`.

             Timestamp timestamp;
             timestamp.set_seconds(time(NULL));
             timestamp.set_nanos(0);

         Example 2: Compute Timestamp from POSIX `gettimeofday()`.

             struct timeval tv;
             gettimeofday(&tv, NULL);

             Timestamp timestamp;
             timestamp.set_seconds(tv.tv_sec);
             timestamp.set_nanos(tv.tv_usec * 1000);

         Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.

             FILETIME ft;
             GetSystemTimeAsFileTime(&ft);
             UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;

             // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
             // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
             Timestamp timestamp;
             timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
             timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));

         Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.

             long millis = System.currentTimeMillis();

             Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
                 .setNanos((int) ((millis % 1000) * 1000000)).build();

         Example 5: Compute Timestamp from Java `Instant.now()`.

             Instant now = Instant.now();

             Timestamp timestamp =
                 Timestamp.newBuilder().setSeconds(now.getEpochSecond())
                     .setNanos(now.getNano()).build();

         Example 6: Compute Timestamp from current time in Python.

             timestamp = Timestamp()
             timestamp.GetCurrentTime()

         # JSON Mapping

         In JSON format, the Timestamp type is encoded as a string in the
         [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
         format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
         where {year} is always expressed using four digits while {month}, {day},
         {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
         seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
         are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
         is required. A proto3 JSON serializer should always use UTC (as indicated by
         "Z") when printing the Timestamp type and a proto3 JSON parser should be
         able to accept both UTC and other timezones (as indicated by an offset).

         For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
         01:30 UTC on January 15, 2017.

         In JavaScript, one can convert a Date object to this format using the
         standard
         [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
         method. In Python, a standard `datetime.datetime` object can be converted
         to this format using
         [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
         the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
         the Joda Time's [`ISODateTimeFormat.dateTime()`](
         http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()
         ) to obtain a formatter capable of generating timestamps in this format.
    io.swagger.petstore.v2.Foo2Request:
      type: object
      properties:
        propertyInPathOk:
          type: string
          title: property_in_path_ok
        parentMsg:
          title: parentMsg
          $ref: '#/components/schemas/io.swagger.petstore.v2.Something'
        propertyInQueryOk:
          type: string
          title: property_in_query_ok
      title: Foo2Request
      additionalProperties: false
    io.swagger.petstore.v2.Foo2Response:
      type: object
      title: Foo2Response
      additionalProperties: false
    io.swagger.petstore.v2.MaskyRequest:
      type: object
      properties:
        fields:
          title: fields
          $ref: '#/components/schemas/google.protobuf.FieldMask'
      title: MaskyRequest
      additionalProperties: false
    io.swagger.petstore.v2.Something:
      type: object
      properties:
        propertyInPath:
          type: string
          title: property_in_path
        propertyInQuery:
          type: string
          title: property_in_query
      title: Something
      additionalProperties: false
    io.swagger.petstore.v2.TimestampyRequest:
      type: object
      properties:
        ts:
          title: ts
          $ref: '#/components/schemas/google.protobuf.Timestamp'
        s:
          title: s
          $ref: '#/components/schemas/google.protobuf.StringValue'
      title: TimestampyRequest
      additionalProperties: false
security: []
tags:
  - name: io.swagger.petstore.v2.Foo
